/*#include <stdio.h>
#include <stdlib.h>

#define N		8		// 노드의 수, 63개의 노드
#define M		9999	// 무한대(MAXIMUM)의 의미


int matrix[N][N] = {	// 입력 데이터
{ 0, 2,-1,-1,-1, 3,-1,-1},
{ 2, 0, 1, 4,-1,-1,-1,-1},
{-1, 1, 0,-1, 3,-1,-1,-1},
{-1, 4,-1, 0, 3,-1, 2,-1},
{-1,-1, 3, 3, 0,-1,-1, 4},
{ 3,-1,-1,-1,-1, 0, 6,-1},
{-1,-1,-1, 2,-1, 6, 0, 4},
{-1,-1,-1,-1, 4,-1, 4, 0}
};



int main()
{
	char temp[16];					// 그냥 시작 노드를 입력받기 위한 키보드 입력용 버퍼
	int start, cur;					// 각각 시작 노드 번호, 현재 처리중인 노드 번호를 저장할 변수
	int i,j;						// 반복문(for)을 돌리기 위한 변수
	int min;						// 현재 처리중인 최소값을 저장하기 위한 변수
	int cost[N];					// (시작점에서) 각 노드로의 비용을 저장하기 위한 배열변수
	int solution[N];				// 확정이 된 (계산이 끝난) 노드인지 표시하는 기능

	// 우선 입력된 데이터중 -1을 처리하기 편하도록 충분히 큰 정수로 변환한다.
	for(i=0 ; i<N ; i++)
	{
		for(j=0; j<N ; j++)
		{
			if(matrix[i][j] == -1)
				matrix[i][j] = M;				// 사전에 정의된 Maximum값
		}
	}



	printf("시작점이 되는 노드의 번호(1 ~ %d번)를 입력해주세요 :", N);
	gets(temp);
	start = atoi(temp)-1;						// 배열의 첨자는 실제로 1번이 아닌 0번부터 시작되므로 내부적으로는 -1씩 작은 노드번호로 계산된다.

	for(i=0 ; i<N; i++)							// 결과가 저장 될 공간을 초기화 하기 위해 N만큼 루프를 돈다
	{
		cost[i] = M;							// 비용(사용자가 지정한 노드 -> i번 노드로의 비용을 의미)
		solution[i] = 0;						// 확정된 노드인지 여부 (1이라면 계산이 끝나서 더이상 후보 노드가 아님을 의미)
	}
	cost[start] = 0;							// 시작점(start번 노드)에서 시작점으로는 당연히 비용이 0

	for(i=0 ; i<N ; i++)						// 총 노드의 개수만큼 루프를 돈다.
	{
		min = M;								// 우선 최소값을 Maximum으로 놓고 시작
		for(j=0 ; j<N ; j++)					// 서브 루프문, 사용되지 않은 노드중 비용이 최소인 노드를 찾기 위한 것임. 
		{
			if(solution[j]==0 && cost[j]<min)	//남아있는 노드(solution[i]가 0인)의 비용 중 현재 최소값보다 작으면
			{	
				cur = j;						// 노드 번호 기록.
				min = cost[j];					// 그 비용을 최소값으로 기록
			}
		}
		solution[cur] = 1;						// 기록한 노드은 사용된 노드으로 마킹. 

		if(min == M)							// min값이 M(무한대값)이면 위의 for문에서 최소값을 구하지 못한 것, 즉 연결이 안되어있다는 의미
		{
			printf("그래프가 연결되어있지 않음.\n");
			return 1;
		}

		for(j=0 ; j<N ; j++)						// 두번째 서브 루프문, 최소비용을 확정하기 위한 루프문이다
		{
			if(solution[j] ==1)						// 새로 계산해 낼 노드이 이미 확정된 노드이라면 계산할 필요없으므로
				continue;							// 패스.
			if(cost[cur]+matrix[cur][j] < cost[j])	// 현재 노드별로 저장된 비용(시작점으로부터의)과 위에서 얻어낸 최소비용을 가지는 노드과의 비용합
				cost[j] = cost[cur] + matrix[cur][j];	// 이 이전에 저장된 비용보다 작으면 갱신해 준다. 
		}
	}

	// 저장된 노드별 결과를 화면에 출력
	for(i=0 ; i<N ; i++)
		printf("노드 %d -> %d 로의 최소비용: %d\n", start+1, i+1, cost[i]);

	system("pause");								// 프로그램이 즉시 종료되지 않도록 입력대기 (도스 명령어)
	return 1;
}
